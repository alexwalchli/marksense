{"version":3,"sources":["webpack:///webpack/bootstrap 15f78885d72e2fae7fc4","webpack:///./demo/index.js","webpack:///./src/core/marksense.js"],"names":["window","MarkSense","corpus","lines","split","filter","line","match","indexOf","map","code","l","trim","depth","chain","children","parent","undefined","i","getParentFromIndex","find","child","count","push","probability","length","Object","keys","forEach","node","key","childrenCount","reduce","acc","curr","idx","currDepth"],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;ACtCA;;;;;;AACAA,QAAOC,SAAP,uB;;;;;;;;;;;;;;;;KCDqBA,S;AACnB,wBAAa;AAAA;AACZ;;AAED;AACA;AACA;;;;;yCACoBC,M,EAAO;AAAA;;AACzB,WAAMC,QAAQD,OAAOE,KAAP,OAAmBC,MAAnB,CAA0B;AAAA,gBAAQ,EAAEC,SAAS,IAAT,IAAiBA,KAAKC,KAAL,CAAW,MAAX,MAAuB,IAAxC,IAAgDD,KAAKE,OAAL,CAAa,GAAb,IAAoB,CAAC,CAAvE,CAAR;AAAA,QAA1B,EACXC,GADW,CACP,aAAK;AAAE,gBAAO;AACjBC,iBAAMC,EAAEC,IAAF,EADW;AAEjBC,kBAAO,MAAKA,KAAL,CAAWF,CAAX;AAFU,UAAP;AAIb,QALa,CAAd;;AAOA,WAAIG,QAAQ,EAAZ;AACAA,aAAM,UAAN,IAAoB;AAClBD,gBAAO,CADW;AAElBE,mBAAU,EAFQ;AAGlBC,iBAAQC;AAHU,QAApB;;AATyB,kCAejBC,CAfiB;AAgBvB,aAAMZ,OAAOH,MAAMe,CAAN,CAAb;AAAA,aACMF,SAAS,MAAKG,kBAAL,CAAwBhB,KAAxB,EAA+Be,CAA/B,EAAkCZ,KAAKO,KAAvC,CADf;;AAGA,aAAGC,MAAMR,KAAKI,IAAX,CAAH,EAAoB;AAClBI,iBAAME,OAAON,IAAb,EAAmBK,QAAnB,CAA4BK,IAA5B,CAAiC,UAACC,KAAD;AAAA,oBAAWA,MAAMX,IAAN,KAAeJ,KAAKI,IAA/B;AAAA,YAAjC,EAAsEY,KAAtE;AACD,UAFD,MAEO;AACLR,iBAAME,OAAON,IAAb,EAAmBK,QAAnB,CAA4BQ,IAA5B,CAAiC;AAC/Bb,mBAAMJ,KAAKI,IADoB;AAE/Bc,0BAAa,CAFkB;AAG/BF,oBAAO;AAHwB,YAAjC;;AAMAR,iBAAMR,KAAKI,IAAX,IAAmB;AACjBG,oBAAOP,KAAKO,KADK;AAEjBG,qBAAQA,OAAON,IAFE;AAGjBK,uBAAU;AAHO,YAAnB;AAKD;AAjCsB;;AAezB,YAAI,IAAIG,IAAI,CAAZ,EAAeA,IAAIf,MAAMsB,MAAzB,EAAiCP,GAAjC,EAAqC;AAAA,eAA7BA,CAA6B;AAmBpC;;AAEDQ,cAAOC,IAAP,CAAYb,KAAZ,EAAmBc,OAAnB,CAA2B,eAAO;AAChC,aAAMC,OAAOf,MAAMgB,GAAN,CAAb;AAAA,aACYC,gBAAgBF,KAAKd,QAAL,CAAciB,MAAd,CAAqB,UAACC,GAAD,EAAMC,IAAN,EAAe;AAClD,kBAAOD,MAAMC,KAAKZ,KAAlB;AACD,UAFe,EAEb,CAFa,CAD5B;AAIAO,cAAKd,QAAL,CAAca,OAAd,CAAsB,iBAAS;AAC3BP,iBAAMG,WAAN,GAAoBH,MAAMC,KAAN,GAAcS,aAAlC;AACD,UAFH;AAGD,QARD;;AAUA,YAAKjB,KAAL,GAAaA,KAAb;;AAEA,cAAOA,KAAP;AACD;;;oCAEcJ,I,EAAK;AAClB;;AAEA,cAAO,KAAKI,KAAL,CAAWJ,IAAX,CAAP;AACD;;;wCAEkBP,K,EAAOgC,G,EAAKC,S,EAAU;AACvC,WAAGA,cAAc,CAAjB,EAAmB;AACjB,gBAAO,EAAE1B,MAAM,UAAR,EAAoBG,OAAO,CAA3B,EAAP;AACD;;AAED;AACA,YAAI,IAAIK,IAAIiB,MAAM,CAAlB,EAAqBjB,KAAK,CAA1B,EAA6BA,GAA7B,EAAiC;AAC/B,aAAGf,MAAMe,CAAN,EAASL,KAAT,GAAiBuB,SAApB,EAA8B;AAC5B,kBAAOjC,MAAMe,CAAN,CAAP;AACD;AACF;AACF;;;2BAEKZ,I,EAAK;AACT,cAAOA,KAAKF,KAAL,CAAW,IAAX,EAAiBqB,MAAxB;AACD;;;;;;mBA/EkBxB,S","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 15f78885d72e2fae7fc4\n **/","import MarkSense from '../src/core/marksense';\nwindow.MarkSense = MarkSense;\n\n\n/** WEBPACK FOOTER **\n ** ./demo/index.js\n **/","export default class MarkSense{\n  constructor(){\n  }\n\n  // TODO: This can probably be done in a single loop \n  // but will do for a prototype for now.\n  // TODO: generate n-grams for finding suggestions\n  generateMarkovChain(corpus){\n    const lines = corpus.split(`\\n`).filter(line => !(line === null || line.match(/^ *$/) !== null || line.indexOf('}') > -1))\n      .map(l => { return {\n        code: l.trim(),\n        depth: this.depth(l)\n      };\n    });\n\n    var chain = {};\n    chain['__ROOT__'] = {\n      depth: 0,\n      children: [],\n      parent: undefined\n    };\n\n    for(let i = 0; i < lines.length; i++){\n      const line = lines[i],\n            parent = this.getParentFromIndex(lines, i, line.depth);\n\n      if(chain[line.code]){\n        chain[parent.code].children.find((child) => child.code === line.code).count++;\n      } else {\n        chain[parent.code].children.push({\n          code: line.code,\n          probability: 0,\n          count: 1\n        });\n\n        chain[line.code] = {\n          depth: line.depth,\n          parent: parent.code,\n          children: []\n        };\n      }\n    }\n\n    Object.keys(chain).forEach(key => {\n      const node = chain[key],\n                  childrenCount = node.children.reduce((acc, curr) => {\n                    return acc + curr.count;\n                  }, 0);\n      node.children.forEach(child => {\n          child.probability = child.count / childrenCount;\n        });\n    });\n\n    this.chain = chain;\n\n    return chain;\n  }\n\n  getSuggestions(code){\n    // TODO: generate n-grams and use them to find suggestions from partially typed lines\n\n    return this.chain[code];\n  }\n\n  getParentFromIndex(lines, idx, currDepth){\n    if(currDepth === 1){\n      return { code: '__ROOT__', depth: 0};\n    }\n\n    // traverse backwards until a node is hit with less depth, it's parent\n    for(let i = idx - 1; i >= 0; i--){\n      if(lines[i].depth < currDepth){\n        return lines[i];\n      }\n    }\n  }\n\n  depth(line){\n    return line.split('  ').length;\n  }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/marksense.js\n **/"],"sourceRoot":""}